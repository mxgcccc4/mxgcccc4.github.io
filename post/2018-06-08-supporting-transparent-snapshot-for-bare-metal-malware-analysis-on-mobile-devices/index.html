<!DOCTYPE html>
<html lang="en-us">
<head>
	<title>[ACSAC 2017] Supporting Transparent Snapshot for Bare-metal Malware Analysis on Mobile Devices&middot; mxgcccc4&#39;s blog</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="MXGC">
	<meta name="description" content="A security research blog of MXGC">
	
	<meta name="generator" content="Hugo 0.55.6" />

	<!-- CSS -->
	<link rel="stylesheet" href="https://mxgcccc4.github.io/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="https://mxgcccc4.github.io/favicon.ico" type="image/x-icon">

	<!-- RSS -->
	

	<!-- Font Awesome -->
	<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">

	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/default.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
	<header class="site-header">
	<div class="branding">
		<a href="https://mxgcccc4.github.io/">
		<img class="avatar" src="https://mxgcccc4.github.io/avatar.ico" alt=""/>
		</a>
		<h1 class="site-title">
			<a href="https://mxgcccc4.github.io/">mxgcccc4&#39;s blog</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			<li><a href="/about/"> About </a></li>

			<li class="icon">
	<a href="https://mxgcccc4.github.io/" title="">
		<i class="fa fa-fw fa-home"></i>
	</a>
</li>

<li class="icon">
	<a href="https://mxgcccc4.github.io/index.xml" title="Subcribe">
		<i class="fa fa-fw fa-rss"></i>
	</a>
</li>

<li class="icon">
	<a href="mailto:sec_mxgc@sjtu.edu.cn" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>









































		</ul>
	</nav>
</header>


	<div class="content">
	<article>
		<header>
			<h1 class="title">[ACSAC 2017] Supporting Transparent Snapshot for Bare-metal Malware Analysis on Mobile Devices</h1>
			<p class="meta">
    June 8, 2018 &middot; 1 minute read  &middot; Tags: <a href="https://mxgcccc4.github.io/tags/acsac">ACSAC</a> , <a href="https://mxgcccc4.github.io/tags/android">Android</a> , <a href="https://mxgcccc4.github.io/tags/malware">Malware</a> , <a href="https://mxgcccc4.github.io/tags/paper-note">Paper Note</a> 
</p>
		</header>

		<section class="post-content">
			<p>作者： Le Guan, Shijie Jia, Bo Chen, Fengwei Zhang, Bo Luo&hellip;</p>

<p>单位： Pennsylvania State University, Data Assurance and Communication Security Research Center, Michigan Technological University</p>

<p>出处： ACSAC 2017</p>

<p>资料： <a href="http://www.cs.wayne.edu/fengwei/paper/bolt-acsac17.pdf">Paper</a></p>

<hr/>

<h2 id="abstract">ABSTRACT</h2>

<p>随着针对移动设备的网络犯罪数量的激增，对于移动恶意软件分析平台有很大的需求。因为许多恶意软件都包含出虚拟机检测能力，所以大多数情况下都直接采用真机作为分析平台。然而现有的工作的关注点主要在如何能够通过真机分析提取恶意软件的行为。但是当恶意应用分析结束之后，能够把真机恢复到分析恶意软件之前也很重要。然而对于移动平台现有的最佳的解决方案只能恢复硬盘存储空间，并且需要花费时间重启。另外先有的工作还需要在分析平台中依赖一部分组件才能完成恢复工作。因此，有些kernel-level级别的恶意软件仍然能够检测到这些组件的存在。</p>

<p>作者提出了Bolt这样一个透明的恢复机制在不需要重启的情况下把移动分析平台恢复到恶意软件分析之前的状态。 Bolt这种不需要重启的恢复机制能够同时对disk和memory制作快照。内存快照是通过存在于ARM TrustZone的一个独立的操作系统（BoltOS）去实现的。而disk的快照是通过一块固件经过定制（BoltFTl）的闪存设备去实现的。因为BoltOS和BoltFTL都独立于guestOS（论文中为了方便，作者把所有直接运行恶意软件的操作系统统一称为guestOS），所以就算是kernel-level的恶意软件也不会影响恢复行为。而且，Bolt不需要对guestOS进行任何的修改。因此，Bolt是第一个做到能够高效，独立，并且隐蔽地从被恶意软件感染之后的状态恢复。</p>

<h2 id="introduction">Introduction</h2>

<p>尽管基于静态分析和指纹的恶意软件的分析技术已经十分成熟，但是仍然不能检测所有的恶意软件。特别地，对于一些使用了混淆，加壳以及多态性的恶意软件，静态分析技术就显得捉襟见肘。动态分析技术则可以通过把恶意软件样本运行在沙箱环境中去克服这些问题。而一些狡猾的恶意软件或者带有虚拟机检测功能的样本则会检测自己所存在的环境。今年来，越来越多的研究人员使用动态分析技术去分析恶意软件，他们把恶意软件运行在安装了未经过修改的操作系统的实体机器上。如果恶意软件检测出运行在真实的机器上就会开始恶意行为。恶意分析有两个比较重要的问题：第一，如果不在guestOS中添加辅助组件，很难透明并且精确地收集恶意软件的行为；第二，实体机器不像虚拟化的解决方案，每次恢复分析环境到未被恶意软件执行过的环境，是必须要经过重启的，那么势必会带来比较长的时间消耗。那么越来越多的恶意软件分析就需要更为快速的系统恢复过程。</p>

<p>对于第一个关键的问题，已经有很多分析框架能够解决这些问题，但是很少有人关注系统的快速恢复过程。现有的快速恢复的方案需要对guestOS进行修改，这样破坏了操作系统对于恶意软件的透明性，或者只能恢复系统的一部分状态。有些方案，例如BareBox可以做到恢复包括memory和disk在内的系统状态。但是它在guestOS中帮助恢复系统的服务和程序和guest系统的权限的是相同，那么kernel-level的恶意软件就能够干扰恢复的过程。</p>

<p>在本文中，作者提出了Bolt，一个运行在ARM设备上的快速恢复系统状态机制。Bolt能够恢复运行在实体机器上那些未经过修改的操作系统。作者利用了两种硬件特性：ARM的TrustZone的安全扩展和基于闪存的存储设备。这两种硬件特性存在与主流的ARM设备上。</p>

<p>通过借助TrustZone和Flash 闪存，Bolt能够在不重启的情况下对内存和磁盘状态进行完整地恢复：</p>

<ol>
<li>对于内存状态，Bolt把物理内存分为三个区域：一块为secure world的TrustedOS，一块为normal-world，另一块为guestOS的快照。BoltOS运行在TrustZone，负责保存/恢复guestOS的内存快照。内存快照只能BoltOS能够访问。</li>
<li>对于磁盘状态，Bolt是利用基于闪存的块设备的out-of-place实现的。作者通过修改了闪存固件所提供给操作系统的接口来实现利用闪存设备的特性做到快速恢复磁盘状态。</li>
</ol>

<p>因为BoltOS工作在TrustZone，所以对于恶意软件来说有很强的隐蔽性。作者的主要工作如下：</p>

<ul>
<li>提出了Bolt，一种能够实现高效、快速、隐蔽恢复整个系统的方案；</li>
<li>设计了一种联结BoltOS和基于闪存块的设备的算法；</li>
<li>把Android系统当做guestOS实现了Bolt的原型，并且能够在2.8s之内做到恢复整个操作系统到原始状态。<br /></li>
</ul>

<h2 id="background">Background</h2>

<h3 id="2-1-android">2.1 Android</h3>

<p>因为不需要重启，所以Bolt在恢复系统状态到原始状态的时候，只需要恢复<code>System</code>和<code>Data</code>分区就可以了。</p>

<h3 id="2-2-arm-trustzone-and-its-usage-in-android">2.2 ARM TrustZone and Its Usage in Android</h3>

<p>TrustZone是ARM架构的处理器提供的一种安全扩展，它可以提供一个独立的执行环境。ARM TrustZone提供了两个虚拟处理器运行不同的权限级别。正常的移动操作系统例如Andoird和iOS以较低的权限运行在normal world，而secure world则会运行一个轻量级的操作系统以运行一些可信的程序，这些程序为设备提供了可信的服务，例如指纹识别。而当前执行环境是normal还是secure world取决于Security Configuration Register中的NS（non-secure）位，NS位只有当CPU运行在secure world的时候才可以被修改。</p>

<h3 id="2-3-flashed-based-clock-devices">2.3 Flashed-based Clock Devices</h3>

<p>基于闪存的块设备例如eMMC卡、SD卡、microSd卡，SSD驱动等因为高性能的IO和更低的功耗都已经取代了传统的HDD。而移动设备中大规模采用eMMC和SD卡。</p>

<p><strong>Flash Memory</strong> 闪存是一种可擦除和可编程的存储介质。相对与HDD，闪存拥有很多特性。闪存上的页在被擦除之前是可重复编程的，然而因为擦除操作只能通过块操作完成，所以覆盖一个很小的页需要擦除整个block，那么就需要在擦除之前复制出这个块上所有其他有效的数据。然后在擦除完整个块之后再将有效数据写回。这就导致了很大不必要的开销。为了解决这个问题，闪存通常使用一种<code>out-of-place</code>的策略。当一个页被覆盖的时候，会简单地把新的数据存储在空闲页，然后标记旧的页面为<code>invalid</code>，<code>invalid</code>页会在垃圾回收时被清理，而不是数据写入时候。如下图所示，当HDD上的数据被写入时，会直接覆盖逻辑页和物理页，而在闪存中，当页被写入新数据时候，会把数据卸载其他空闲的页，然后把A页标记为<code>invalid</code>。</p>

<p><img src="https://i.imgur.com/aqb6UJf.png" alt="1528462709144" /></p>

<p>无效的页的清理过程如下：</p>

<ol>
<li>选择那些失效页超过某个阈值的块，当做<code>victim</code>块</li>
<li>复制这个<code>victim</code>块上所有的有效页的数据到空闲块</li>
<li>直接擦除<code>victim</code>块</li>
</ol>

<p><strong>Flash translation layer</strong> 为了兼容设备块文件系统（EXT4, FAT32），闪存介质通常会用来模拟当做块设备。而FTL（Flash translation layer）的作用就是通过管理raw flash并提供一个基于块的访问借口给上层的文件系统。如下图所示，FTL把逻辑页的地址从上层（文件系统）转换为物理页的地址。</p>

<p><img src="https://i.imgur.com/bDk6xSf.png" alt="1528463162199" /></p>

<h2 id="design">Design</h2>

<h3 id="3-1-threat-model-and-assumptions">3.1 Threat Model and Assumptions</h3>

<p>在Bolt中，作者的威胁模型认为恶意软件会获取normal world的最高权限。同样它们拥有内核级的权限，并且恶意软件可以破坏SE Linux的安全策略。并且假设guest系统支持TEE环境。Bolt仅仅依赖normal world中的已有的代码去调用快照服务。</p>

<h3 id="3-2-overview">3.2 Overview</h3>

<p>Bolt由四个部分构成：</p>

<p><img src="https://i.imgur.com/POFKWq0.png" alt="1528463923828" /></p>

<h5 id="boltagent">BoltAgent</h5>

<p>这是一个运行在Android系统中的app，这个app并不会引起恶意软件的怀疑，它只对TEE环境中的服务发起两个不同的请求。例如指纹识别或者trusted keyStore。BoltOS接收来自BoltAgent的save/restore操作请求。如下图。</p>

<p><img src="https://i.imgur.com/pOp4QIK.png" alt="1528547571704" /></p>

<h5 id="boltos">BoltOS</h5>

<p>BoltOS是运行在secure world的一个负责系统恢复服务的轻量级操作系统。特别地指纹别是与<code>save</code>操作联系在一起的，而trusted keyStore是于<code>restore</code>联系在一起的。如上图所示，当BoltOS收到来自BoltAgent的请求时，Serve Commodity Server会执行相应保存或者恢复操作。一个快照包括两部分，内存快照和磁盘快照。BoltOS直接处理内存快照，然后转发磁盘快照请求给闪存固件。闪存固件对磁盘进行快照操作将会在下一部分描述。为了保存内存镜像。BoltOS简单地直接复制guestOS的整块物理内存，包括通用寄存器，Current Processor State Register（CPSR）和Translation Table Base Register（TTBR）然后存在到BoltOS。</p>

<h5 id="boltftl">BoltFTL</h5>

<p>BoltFTL是一块定制的闪存固件。它能够接收BoltOS发出的特殊的SCSI命令去执行磁盘的<code>save</code>和<code>restore</code>操作。因为利用了<code>out-of-place</code>特性，能够很高效地保存和恢复整块闪存的数据而不用消耗大量的时间。当接收<code>save</code>操作时候，BoltFTL启动垃圾回收去保存干净的状态的系统数据，然后备份FTL的元数据（比如存储LPA和PPA之间关系的映射表）。当BoltFTL接收到恢复操作的时候，BoltFTL直接恢复备份的元数据，BotFTL的细节在3.4节会阐述。</p>

<h5 id="coordinator">Coordinator</h5>

<p>Coordinator是一个在PC端通过ADB连接设备的工具集。它负责下载恶意软件然后push到设备上，然后通过BoltAgent发起save操作去保存系统快照，然后在分析结束之后，通过发起restore请求恢复系统都干净状态。为了防止被感染的Android系统会被恶意软件操作而发起多次save操作影响干净状态的系统快照，只允许接收一次save命令而忽视之后所有的save请求。对于恶意软件有可能干扰BoltAgent发起的恢复操作，而导致恢复失败，在secure world中设置了watchdog，经过一段预先设定的时间之后会直接启动restore操作。</p>

<h3 id="3-3-memory-recovery">3.3 Memory Recovery</h3>

<p>因为BoltOS运行在一个独立的环境中，所以没有物理内存和处理器上下文的循环依赖。保存内存快照的第一步是保存物理内存，在Bolt中把物理内存分为两块区域，一块用来加载guestOS，一块用来保存guestOS的内存快照。第一个区域是能够被两个world同时访问得到的，第二个内存区域只能被BoltOS访问。保存和恢复都只需要由BoltOS直接把物理内存从快照区域复制出来，或者复制进去。</p>

<p>物理内存是和处理器上下文紧密关联的。如果在修改物理内存的时候没有恢复处理器上下文会导致系统的崩溃，所以在恢复的时候除了恢复通用处理器，Bolt也会恢复TTBR，SCTLR和ASID处理器。</p>

<h3 id="3-4-flash-recovery">3.4 Flash Recovery</h3>

<p>为了保证闪存在恢复时的高效，作者利用了闪存的<code>out-of-place</code>的优点。闪存的特点保证了在分析过程中，恶意软件不会因为覆盖了数据而破坏保存的干净状态的快照。作者通过定制闪存的固件（FTL）中的垃圾回收机制，保证保存的数据不会被闪存的垃圾回收机制所擦除。因为FTL存在于操作系统和闪存之间，对操作系统来说FTL是透明的。这样的话就算恶意软件获取了内核级的权限也不会干扰整个过程。</p>

<p>BoltFTL对磁盘的保存和恢复过程包括以下步骤：</p>

<ol>
<li>准备阶段：首先FTL会出发垃圾回收机制把数据保存在空闲块上，然后擦除victim块，然后FTL对必要的元数据做备份，保证元数据的大小远小于保存的数据。块保存的元数据对于上层来说是不可见的。</li>
<li>分析阶段：开始恶意软件分析，<code>read</code>操作直接和没有修改的闪存固件操作逻辑相同；<code>write</code>操作则是保证包含干净状态和备份元数据的块<code>never</code>选中，保证备份数据不被干扰；<code>garbage collection</code>则是经过修改之后保证备份数据所在的区块也<code>never</code>被选中。</li>
<li>恢复阶段：BoltOS直接发送恢复命令给BoltFTL开始恢复过程。BoltFTL在收到命令之后，直接通过闪存控制器恢复原有的元数据和备份数据到磁盘。</li>
</ol>

<h2 id="implementation">Implementation</h2>

<p>作者基于Bolt在一块内存为1GB和iRAM为256KB的ARM Soc的i.MX开发板上实现了一个原型机。在normal world运行着Android 7.0的操作系统。因为所有的商业ARM处理器中都实现了一个可信操作系统，所以作者只在此的基础上实现了<code>save</code>和<code>restore</code>服务。作者通过USB连接了一个可编程闪存开发板LPC-H3131到i.MX上。这块闪存上保存着Android系统的<code>System</code>和<code>Data</code>分区。BoltFTL是基于OpenNFM构建的。这是一个开源的NAND闪存控制框架。</p>

<h3 id="4-1-boltos">4.1 BoltOS</h3>

<p>BoltOS通过配置TrustZone Address Space Control(TZASC)来把内存的前512MB设置为Android使用的non-secure资源，把剩下的512MB设置为安全区域用来保存内存快照。最后，把Android的bootloader加载到内存区域，然后切换到normal world运行bootloader，然后Android开机。BoltAgent所请求的服务使用r0寄存器发起。BoltOS可以使用嵌入式设备上的C标准库，所以可以调用<code>memcy</code>之类的函数去加速内存的保存和恢复过程。BoltOS只消耗不到30KB的内存。</p>

<h3 id="4-2-boltftl">4.2 BoltFTL</h3>

<p>使用OpenNFM实现的BoltFTL原型。在BoltFTL中，如前所述作者使用SCSI命令保留的操作码<code>0x61h</code>去通知BoltFTL执行<code>save</code>操作，使用<code>0x62h</code>操作码通知BoltFTl去执行<code>restore</code>操作。</p>

<h2 id="evaluation">Evaluation</h2>

<p>测评部分，作者首先统计恢复guestOS所需要的时间。因为恢复时间严重依赖于硬件，所以也同样统计了不同配置的硬件所需要的时间。最后还统计了通过修改之后的固件访问闪存时候的运行时性能。如果Bolt带来的性能损失比较低，那么恶意软件就不会检测得到。</p>

<h3 id="5-1-restoration-performance">5.1 Restoration Performance</h3>

<h5 id="breakdown-measurements">Breakdown Measurements</h5>

<p><img src="https://i.imgur.com/vVElsWr.png" alt="1528545426685" /></p>

<p>上图显示了恢复过程的进程。接收到恢复命令之后，BoltOS使用自定义的SISC命令通知BoltFTL。然后BoltOS立即开始恢复物理内存和处理器上下文。最后BoltOS把控制权交给guestOS，然后恢复快照拍摄时的执行。因为BoltOS和BoltFTL的始终不同步，所以没有办法准确地统计command transmission的时间长度。表一为每个阶段过程所需要的时间长度，单位为μs。</p>

<p><img src="https://i.imgur.com/AkQoLFY.png" alt="1528545446938" /></p>

<h5 id="restoration-under-varyting-memory-sizes">Restoration under varyting memory sizes</h5>

<p>此部分作者统计了不同大小的物理内存所带来的时间差异。由于硬件的限制，测试所使用的最大内存为512MB。作者测试了从384MB到512MB大小的物理内存。如下表所致。但是内存恢复的时间不仅仅依赖于内存大小，还和SoC有关，性能越强的SoC更能降低恢复时间。</p>

<p><img src="https://i.imgur.com/4wLIn3j.png" alt="1528545473166" /></p>

<h3 id="5-2-flash-runtime-performance">5.2 Flash Runtime Performance</h3>

<p>BoltFTL使用了定制的闪存固件，作者使用AndroBench存储测试工具去测试OpenNFM和BoltFTL之间的性能差距。如图6所示：</p>

<ul>
<li><code>read</code>时候的性能差距几乎没有，因为作者并没有修改固件任何关于<code>read</code>的特性和操作。，所以BoltFTL和OpenNFM的逻辑操作并没有差别。</li>
<li>写的时候，根据作者统计，BoltFTL大约有2%的性能损失，这部分作者认为有以下两个原因：一是FTL会为了加快写操作准备大量的空闲blocks，这些blocks需要被GC的时候被释放。但是因为BoltFTL的原因，固件并没有选择保存了干净状态数据的blocks，那么这样就导致为了准备足够的空闲blocks就会加快GC的频率；二是BoltFTL中的GC会在闪存块之间导致更多的P/E循环。</li>
</ul>

			
		</section>
	</article>
	</div>

	<footer class="site-footer">
	<p class="text">&copy; 2019 - Released under the MIT license<br>Powered by <a href="//gohugo.io/">Hugo</a> with the <a href="//github.com/digitalcraftsman/hugo-type-theme">Type Theme</a></p>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-132921460-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</body>
</html>
